<div>

  <div class="layout">

    <section class="input-form-container template-driven">
      <h4>Template-driven forms</h4>

      <div class="input-container">
        <span>Email</span>
        <input type="email" [(ngModel)]="myEmail"/>
      </div>

      <div class="value-checker">
        <button (click)="randomizeMyEmail()">Randomize Value</button>
        <span><code>myEmail</code> value: </span><span class="text-highlight"> {{myEmail}}</span>
      </div>

      <div class="explain-bubble">
        <span>HTML usage: </span><code>&lt;input type="email" [(ngModel)]="myEmail"/></code>
        <br><br>
        <div><code>[(ngModel)]</code> uses 'banana-in-a-box' syntax:</div>

        <ul>
          <li>🍌 bananas 👉   )   (</li>
          <li>📦 the box   👉 [       ]</li>
        </ul>

        <span>
          Known as <b>Two-way Data Binding</b>, this will link the value in the <code>&lt;input></code>
          with the variable <code>myEmail</code>.
        </span>

        <ul>
          <li>
            When the user types into the input box, it will change the input box's value, and
            also change <code>myEmail</code>
          </li>
          <li>
            When javascript changes <code>myEmail</code>, it will also change the input-box's value
            (and display the new value)
          </li>
        </ul>

        <div>Features:</div>
        <ul>
          <li>Can also be used on custom Angular components</li>
          <li>Allows direct access to modify data in your template, but are less explicit</li>
          <li>Validation logic is spread across lots of HTML code</li>
        </ul>
      </div>
    </section>

    <section class="input-form-container reactive-driven">
      <h4>Reactive forms</h4>

      <div class="input-container">
        <span>Email</span>
        <input type="email" [formControl]="myEmailControl"/>
      </div>

      <div class="value-checker">
        <button (click)="randomizeMyEmailControl()">Randomize Value</button>
        <span><code>myEmailControl.value</code>: </span><span class="text-highlight">{{myEmailControl.value}}</span>
      </div>

      <div class="explain-bubble">
        <span>Setup: </span><code>myEmailControl = new FormControl();</code><br>
        <span>HTML usage: </span><code>&lt;input type="email" [formControl]="myEmailControl"/></code>
        <br><br>
        <div>
          Encapsulates all input logic into a single object. <code>myEmailControl</code> can easily be provided
          with validation logic that range from simple to complex cases:
        </div>
        <ul>
          <li>Simply required: <br><code>new FormControl(null, Validators.required);</code></li>
          <li>Letters only regex pattern: <br><code>new FormControl(null, Validators.pattern('^[a-zA-Z]+$'));</code>
          </li>
          <li>
            Async validation (check if username has already been taken):
            <br><code>new FormControl(null, Validators.required, MyCustomAsyncNetworkValidator);</code>
          </li>
        </ul>

        <div>Features:</div>
        <ul>
          <li>Provides more predictability with synchronous access to the data model</li>
          <li>
            Validation logic can be extended, and interdependent inputs can easily be validated against each other
          </li>
        </ul>
      </div>
    </section>

  </div>

</div>
